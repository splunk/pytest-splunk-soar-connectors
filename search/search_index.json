{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Local Development for Splunk SOAR Connectors","text":"<p>pytest-splunk-soar-connectors is a plugin for the pytest framework that provides a set of mock packages and fixtures for unit testing Splunk SOAR Apps (Connectors). </p> <p>It provides a way to run and test Splunk SOAR connectors locally. Pair it with other pytest packages such as requests-mock or vcrpy to test connectors in total isolation, without a development SOAR instance or even access to the remote system the connector integrates with.</p> <p>Beyond testing, the package can be used to get IDE autocompletions for the <code>phantom</code> package that is typically only found within the Splunk SOAR Python environment. This can ease development significantly. The initial scope of this project is to cover the entire App Authoring API.</p>"},{"location":"#other-projects","title":"Other Projects","text":"<p>Its purpose is similiar to the phantom-test-harness project and some of the features fo the phantom-dev framework.</p>"},{"location":"#support","title":"Support","text":"<p>This is not an official Splunk product.</p>"},{"location":"content/","title":"Content","text":""},{"location":"content/#_1","title":"Content","text":""},{"location":"installation/","title":"Installation","text":"<p>This package is not published to the Python Package Index (PyPi) at this time so we'll outline the steps needed to install the plugin from its Github repository. </p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3</li> </ul> <p>It is strongly recommended to install this package in your projects virtual environment as part of your local development. The commands below assume you are located in the root directory of your SOAR app. If you already have an existing virtual environment, you can skip these steps.</p>"},{"location":"installation/#create-a-virtual-environment-optional","title":"Create a virtual environment (optional)","text":"<pre><code>python3 -m venv venv\nsource venv/bin/activate\n</code></pre>"},{"location":"installation/#install-pytest-splunk-soar-connectors","title":"Install pytest-splunk-soar-connectors","text":"<pre><code>pip install git+https://github.com/splunk/pytest-splunk-soar-connectors\n</code></pre>"},{"location":"limitations/","title":"Limitations","text":"<ul> <li><code>get_ca_bundle</code> currently not implemented</li> <li><code>validate_parameters</code> currently not implemented</li> <li><code>set_validator</code> currently not implemented</li> </ul>"},{"location":"guides/getting_started/","title":"Getting started","text":"<p>This page will guide you through creating a unit test setup for your SOAR connector. It assumes you successfully installed the package in your projects virtual environment. It also assumes you have pytest installed.</p>"},{"location":"guides/getting_started/#preparations","title":"Preparations","text":"<p>Create a <code>tests</code> directory in the root of your connector project if you have not already and create a <code>conftest.py</code> within that directory. <pre><code>mkdir tests &amp;&amp; cd tests\ntouch conftest.py\n</code></pre></p>"},{"location":"guides/getting_started/#loading-the-plugin-in-conftest","title":"Loading the plugin in conftest","text":"<p>In your <code>conftest.py</code> add the plugin to your <code>pytest_plugins</code> definition <pre><code>import pytest\n\n# Load pytest-splunk-soar-connectors plugin\npytest_plugins = (\"splunk-soar-connectors\")\n</code></pre></p>"},{"location":"guides/getting_started/#create-your-connector-fixture","title":"Create your Connector Fixture","text":"<p>Create a new pytest fixture for your connector. The example below uses the connector from the DNS App. We'll use the <code>configure_connector</code> utility function which takes the connector class and the desired asset settings as input.</p> <pre><code>from dns_connector import DNSConnector\nfrom pytest_splunk_soar_connectors import configure_connector\n\n@pytest.fixture(scope=\"function\")\ndef configured_dns_connector():\n    return configure_connector(DNSConnector, {\n        \"dns_server\": \"8.8.8.8\",\n        \"host_name\": \"splunk.com\"\n    })\n</code></pre>"},{"location":"guides/getting_started/#write-a-simple-test","title":"Write a simple test","text":"<p>Now, create a test file in your <code>tests/</code> directory, eg. <code>test_dns_connector.py</code>. Pass the fixture (here: <code>configured_dns_connector</code>) as a parameter to your test. In order to call the action, the <code>_handle_action</code> method of the connector needs to be called with an <code>InputJSON</code>. The <code>InputJSON</code> is simply  a dictionary structure that is initializing the connector run.</p> <p><code>_handle_action</code> returns the action results that were created during the run as a string, so they need to be parsed back into a python list before any <code>asserts</code> can be done.</p> <pre><code>import pytest\nimport json\nimport os\nimport sys\nfrom pytest_splunk_soar_connectors.models import InputJSON\n\nsys.path.insert(0, os.getcwd()) \n\nfrom dns_connector import DNSConnector\n\ndef test_lookup_domain(configured_dns_connector: DNSConnector):\n\n    in_json: InputJSON = {\n        \"action\": \"lookup ip\",\n        \"identifier\": \"forward_lookup\",\n        \"config\": {},\n        \"parameters\": [\n            {\n                \"domain\": \"splunk.com\"\n            }\n        ],\n        \"environment_variables\": {},\n    }\n\n    # Execute Action\n    action_result_str = configured_connector._handle_action(json.dumps(in_json), None)\n    action_result = json.loads(action_result_str)\n\n    # Assertion\n    assert action_result[0][\"summary\"][\"record_info\"] == \"52.5.196.118\"\n</code></pre>"},{"location":"guides/getting_started/#whats-next","title":"What's next?","text":"<p>In the above example, the DNS server was accessible over the internet and could be called as part of a test without any authentication required. But  how do you write tests where you don't have a live instance to test against? Using requests-mock you can  write unittests that are fully offline. Read on in Using requests-mock</p>"},{"location":"guides/using_requests_mock/","title":"Using requests-mocks","text":"<p>The requests-mock package allows to intercept network requests and provide prepared responses to avoid network dependencies in tests. Please refer to its documentation for full background on what it can be used for.</p>"},{"location":"guides/using_requests_mock/#example-test","title":"Example Test","text":"<p>The Connector from the Redmine App is instantiated in <code>conftest.py</code> (not shown) with a <code>base_url</code> pointing to <code>https://localhost:3000</code>. Now in the test, we can use the <code>requests_mock</code> fixture to provide a prepared response to avoid running a local Redmine instance.</p> <pre><code>def test_list_tickets(configured_connector: RedmineConnector, requests_mock):\n\n    # Mock HTTP response\n    sample_issues = {\n        \"issues\": [{\n            \"id\": 1\n        },{\n            \"id\": 2\n        }]\n    }\n\n    requests_mock.get(\"http://localhost:3000/issues.json\", json=sample_issues, headers={\"Content-Type\": \"application/json\"})\n\n    # Configure action parameters\n    in_json = {\n            \"parameters\": {\n                \"identifier\": \"list_tickets\"\n            }\n    }\n\n    # Execute Action\n    action_result_str = configured_connector._handle_action(json.dumps(in_json), None)\n    action_result = json.loads(action_result_str)\n\n    # Assertion\n    assert action_result[0][\"summary\"][\"num_tickets\"] == 2\n</code></pre>"},{"location":"guides/using_vcrpy/","title":"Using VCR.py","text":"<p>Using the VCR.py library may be appropriate if you have access to the remote system in your lab environment from your local laptop, but don't want to configure it within your CI pipeline.</p> <p>By running pytest in different record modes, VCR.py can save network responses to cassettes that can be committed to version control.</p>"},{"location":"guides/using_vcrpy/#example-test","title":"Example Test","text":"<p>Running the below test for the first time with a configured connector pointing to a live instance of Redmine, will create a new <code>cassettes/</code> directory in the <code>tests</code> folder. Within this folder, a local copy of the <code>list_tickets</code> API response will be saved. On following executions, pytest will not do network requests but use the local copy instead.</p> <p>Warning</p> <p>Please ensure that your local copies don't contain sensitive informations such as cookie values, API tokens, passwords. Review the VCR.py documentation on how to scrub sensitive information from your local copy. </p> <pre><code>@pytest.mark.vcr()\ndef test_list_tickets_vcrpy(configured_connector: RedmineConnector):\n\n    # Configure action parameters\n    in_json = {\n            \"parameters\": {\n                \"identifier\": \"list_tickets\"\n            }\n    }\n\n    # Execute Action\n    action_result_str = configured_connector._handle_action(json.dumps(in_json), None)\n    action_result = json.loads(action_result_str)\n\n    # Assertion\n    assert \"issues\" in action_result[0][\"data\"][0]\n</code></pre>"}]}