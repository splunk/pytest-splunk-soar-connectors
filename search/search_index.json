{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to pytest-splunk-soar-connectors pytest-splunk-soar-connectors is a plugin for the pytest framework that provides a set of mock packages and fixtures for unit testing Splunk SOAR Apps (Connectors) . The main feature of the plugin is that it provides a set of python packages that mock the Splunk SOAR Python environment. It's purpose is similiar to the phantom-test-harness project and some of the features fo the phantom-dev framework. It provides an easy way to test Splunk SOAR connectors. Combining it with other pytest packages such as requests-mock or vcrpy , SOAR connectors can be tested in total isolation, without a development SOAR instance or even access to the external system. Design Goals Be easy to integrate into pytest suites Work well with existing connector implementations Create test suites that can run as part of CI Limitations Vault interaction is currently not fully implemented (WIP) get_app_config is not implemented Prerequisites Python 3 (3.7, 3.8, 3.9, 3.10)","title":"Overview"},{"location":"#welcome-to-pytest-splunk-soar-connectors","text":"pytest-splunk-soar-connectors is a plugin for the pytest framework that provides a set of mock packages and fixtures for unit testing Splunk SOAR Apps (Connectors) . The main feature of the plugin is that it provides a set of python packages that mock the Splunk SOAR Python environment. It's purpose is similiar to the phantom-test-harness project and some of the features fo the phantom-dev framework. It provides an easy way to test Splunk SOAR connectors. Combining it with other pytest packages such as requests-mock or vcrpy , SOAR connectors can be tested in total isolation, without a development SOAR instance or even access to the external system.","title":"Welcome to pytest-splunk-soar-connectors"},{"location":"#design-goals","text":"Be easy to integrate into pytest suites Work well with existing connector implementations Create test suites that can run as part of CI","title":"Design Goals"},{"location":"#limitations","text":"Vault interaction is currently not fully implemented (WIP) get_app_config is not implemented","title":"Limitations"},{"location":"#prerequisites","text":"Python 3 (3.7, 3.8, 3.9, 3.10)","title":"Prerequisites"},{"location":"content/","text":"Content","title":"Content"},{"location":"content/#content","text":"","title":"Content"},{"location":"content/#_1","text":"","title":""},{"location":"getting_started/","text":"Getting Started As this plugin is not yet published to the Python Package Index (PyPi) we'll outline the steps needed to install the plugin from its Github repository. It is strongly recommended to install this package in your projects virtual environment as part of your local development. The commands below assume you are located in the the SOAR connectors root directory. If you already have an existing virtual environment, you can skip these steps. Installation python3 -m venv venv source venv/bin/activate pip install git+https://github.com/splunk/pytest-splunk-soar-connectors Connector Fixture Create a tests directory in the root of your connector project if you have not already and create a conftest.py within. mkdir tests && cd tests touch conftest.py Open the created conftest.py in your favorite editor and create a new pytest fixture for your connector. The example below uses the Connector from the DNS App . import os import sys import logging # Add root directory to path sys . path . insert ( 0 , os . getcwd ()) import pytest # Load pytest-splunk-soar-connectors plugin pytest_plugins = ( \"splunk-soar-connectors\" ) # Replace this with the import for your connector from dns_connector import DNSConnector @pytest . fixture ( scope = 'function' ) def configured_connector (): conn = DNSConnector () # Define the asset configuration to be used conn . config = { \"dns_server\" : \"8.8.8.8\" , \"host_name\" : \"splunk.com\" } conn . logger . setLevel ( logging . INFO ) return conn Now, create a test file in your tests/ directory, eg. test_dns_connector.py and define your tests eg. import json import os , sys sys . path . insert ( 0 , os . getcwd ()) import pytest from dns_connector import DNSConnector def test_lookup_domain ( configured_connector : DNSConnector ): in_json = { \"parameters\" : { \"identifier\" : \"forward_lookup\" , \"domain\" : \"splunk.com\" } } # Execute Action action_result_str = configured_connector . _handle_action ( json . dumps ( in_json ), None ) action_result = json . loads ( action_result_str ) # Assertion assert action_result [ 0 ][ \"summary\" ][ \"record_info\" ] == \"52.5.196.118\" def test_lookup_ip ( configured_connector : DNSConnector ): in_json = { \"parameters\" : { \"identifier\" : \"reverse_lookup\" , \"ip\" : \"52.5.196.118\" } } # Execute Action action_result_str = configured_connector . _handle_action ( json . dumps ( in_json ), None ) action_result = json . loads ( action_result_str ) # Assertion assert action_result [ 0 ][ \"summary\" ][ \"cannonical_name\" ] == \"118.196.5.52.in-addr.arpa.\" Mocking Network Calls In this case, the configured DNS server is publicly accessible, so running the action is not an issue. But what if that is not the case? Consider using requests-mock or vcrpy in your tests to avoid doing actual network calls as part of your CI exution.","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"As this plugin is not yet published to the Python Package Index (PyPi) we'll outline the steps needed to install the plugin from its Github repository. It is strongly recommended to install this package in your projects virtual environment as part of your local development. The commands below assume you are located in the the SOAR connectors root directory. If you already have an existing virtual environment, you can skip these steps.","title":"Getting Started"},{"location":"getting_started/#installation","text":"python3 -m venv venv source venv/bin/activate pip install git+https://github.com/splunk/pytest-splunk-soar-connectors","title":"Installation"},{"location":"getting_started/#connector-fixture","text":"Create a tests directory in the root of your connector project if you have not already and create a conftest.py within. mkdir tests && cd tests touch conftest.py Open the created conftest.py in your favorite editor and create a new pytest fixture for your connector. The example below uses the Connector from the DNS App . import os import sys import logging # Add root directory to path sys . path . insert ( 0 , os . getcwd ()) import pytest # Load pytest-splunk-soar-connectors plugin pytest_plugins = ( \"splunk-soar-connectors\" ) # Replace this with the import for your connector from dns_connector import DNSConnector @pytest . fixture ( scope = 'function' ) def configured_connector (): conn = DNSConnector () # Define the asset configuration to be used conn . config = { \"dns_server\" : \"8.8.8.8\" , \"host_name\" : \"splunk.com\" } conn . logger . setLevel ( logging . INFO ) return conn Now, create a test file in your tests/ directory, eg. test_dns_connector.py and define your tests eg. import json import os , sys sys . path . insert ( 0 , os . getcwd ()) import pytest from dns_connector import DNSConnector def test_lookup_domain ( configured_connector : DNSConnector ): in_json = { \"parameters\" : { \"identifier\" : \"forward_lookup\" , \"domain\" : \"splunk.com\" } } # Execute Action action_result_str = configured_connector . _handle_action ( json . dumps ( in_json ), None ) action_result = json . loads ( action_result_str ) # Assertion assert action_result [ 0 ][ \"summary\" ][ \"record_info\" ] == \"52.5.196.118\" def test_lookup_ip ( configured_connector : DNSConnector ): in_json = { \"parameters\" : { \"identifier\" : \"reverse_lookup\" , \"ip\" : \"52.5.196.118\" } } # Execute Action action_result_str = configured_connector . _handle_action ( json . dumps ( in_json ), None ) action_result = json . loads ( action_result_str ) # Assertion assert action_result [ 0 ][ \"summary\" ][ \"cannonical_name\" ] == \"118.196.5.52.in-addr.arpa.\"","title":"Connector Fixture"},{"location":"getting_started/#mocking-network-calls","text":"In this case, the configured DNS server is publicly accessible, so running the action is not an issue. But what if that is not the case? Consider using requests-mock or vcrpy in your tests to avoid doing actual network calls as part of your CI exution.","title":"Mocking Network Calls"},{"location":"guides/","text":"Guides This section provides goal-oriented guides that explain how to use the package effectively in combination with other pytest plugins.","title":"Overview"},{"location":"guides/#guides","text":"This section provides goal-oriented guides that explain how to use the package effectively in combination with other pytest plugins.","title":"Guides"},{"location":"guides/using_requests_mock/","text":"Using requests-mocks The requests-mock package allows to intercept network requests and provide prepared responses to avoid network dependencies in tests. Please refer to its documentation for full background on what it can be used for. Example Test The Connector from the Redmine App is instantiated in conftest.py (not shown) with a base_url pointing to https://localhost:3000 . Now in the test, we can use the requests_mock fixture to provide a prepared response to avoid running a local Redmine instance. def test_list_tickets ( configured_connector : RedmineConnector , requests_mock ): # Mock HTTP response sample_issues = { \"issues\" : [{ \"id\" : 1 },{ \"id\" : 2 }] } requests_mock . get ( \"http://localhost:3000/issues.json\" , json = sample_issues , headers = { \"Content-Type\" : \"application/json\" }) # Configure action parameters in_json = { \"parameters\" : { \"identifier\" : \"list_tickets\" } } # Execute Action action_result_str = configured_connector . _handle_action ( json . dumps ( in_json ), None ) action_result = json . loads ( action_result_str ) # Assertion assert action_result [ 0 ][ \"summary\" ][ \"num_tickets\" ] == 2","title":"Using requests-mock"},{"location":"guides/using_requests_mock/#using-requests-mocks","text":"The requests-mock package allows to intercept network requests and provide prepared responses to avoid network dependencies in tests. Please refer to its documentation for full background on what it can be used for.","title":"Using requests-mocks"},{"location":"guides/using_requests_mock/#example-test","text":"The Connector from the Redmine App is instantiated in conftest.py (not shown) with a base_url pointing to https://localhost:3000 . Now in the test, we can use the requests_mock fixture to provide a prepared response to avoid running a local Redmine instance. def test_list_tickets ( configured_connector : RedmineConnector , requests_mock ): # Mock HTTP response sample_issues = { \"issues\" : [{ \"id\" : 1 },{ \"id\" : 2 }] } requests_mock . get ( \"http://localhost:3000/issues.json\" , json = sample_issues , headers = { \"Content-Type\" : \"application/json\" }) # Configure action parameters in_json = { \"parameters\" : { \"identifier\" : \"list_tickets\" } } # Execute Action action_result_str = configured_connector . _handle_action ( json . dumps ( in_json ), None ) action_result = json . loads ( action_result_str ) # Assertion assert action_result [ 0 ][ \"summary\" ][ \"num_tickets\" ] == 2","title":"Example Test"},{"location":"guides/using_vcrpy/","text":"Using VCR.py Using the VCR.py library may be appropriate if you have access to the remote system in your lab environment from your local laptop, but don't want to configure it within your CI pipeline. By running pytest in different record modes , VCR.py can save network responses to cassettes that can be committed to version control. Example Test Running the below test for the first time with a configured connector pointing to a live instance of Redmine, will create a new cassettes/ directory in the tests folder. Within this folder, a local copy of the list_tickets API response will be saved. On following executions, pytest will not do network requests but use the local copy instead. Warning Please ensure that your local copies don't contain sensitive informations such as cookie values, API tokens, passwords. Review the VCR.py documentation on how to scrub sensitive information from your local copy. @pytest . mark . vcr () def test_list_tickets_vcrpy ( configured_connector : RedmineConnector ): # Configure action parameters in_json = { \"parameters\" : { \"identifier\" : \"list_tickets\" } } # Execute Action action_result_str = configured_connector . _handle_action ( json . dumps ( in_json ), None ) action_result = json . loads ( action_result_str ) # Assertion assert \"issues\" in action_result [ 0 ][ \"data\" ][ 0 ]","title":"Using VCR.py"},{"location":"guides/using_vcrpy/#using-vcrpy","text":"Using the VCR.py library may be appropriate if you have access to the remote system in your lab environment from your local laptop, but don't want to configure it within your CI pipeline. By running pytest in different record modes , VCR.py can save network responses to cassettes that can be committed to version control.","title":"Using VCR.py"},{"location":"guides/using_vcrpy/#example-test","text":"Running the below test for the first time with a configured connector pointing to a live instance of Redmine, will create a new cassettes/ directory in the tests folder. Within this folder, a local copy of the list_tickets API response will be saved. On following executions, pytest will not do network requests but use the local copy instead. Warning Please ensure that your local copies don't contain sensitive informations such as cookie values, API tokens, passwords. Review the VCR.py documentation on how to scrub sensitive information from your local copy. @pytest . mark . vcr () def test_list_tickets_vcrpy ( configured_connector : RedmineConnector ): # Configure action parameters in_json = { \"parameters\" : { \"identifier\" : \"list_tickets\" } } # Execute Action action_result_str = configured_connector . _handle_action ( json . dumps ( in_json ), None ) action_result = json . loads ( action_result_str ) # Assertion assert \"issues\" in action_result [ 0 ][ \"data\" ][ 0 ]","title":"Example Test"},{"location":"reference/","text":"","title":"Reference"}]}